# 递推

## 简介

递推其实是一个数学思想，相当于从一些已知的**小**规模的问题推到**大**规模的问题，对于这类问题只要我们找到递推式就能很好的解答，而与之相对应的是递归，他是从一个大规模的问题推导到小规模的问题，再从小规模的问题往上递推从而得到大规模问题的解
```
形如：a[i] = a[i - 1] + a[i - 2];
```
当某个问题能写出递推式的时候就能考虑用递推的思维去做，我们应该先确定初始**边界条件**，然后从边界逐步推导知道遇到我们想要的答案
注：递推是动态规划问题的基础，动态规划问题中想要进行状态的转移就需要用到递推的思想
但需要注意：能用dp的问题一定都有递推式，但是并不是所有递推式的问题都需要或者适合用dp

## 经典样例
1. 斐波那契数列
	a[i] = a[i - 1] + a[i - 2];
2. 杨辉三角
3. 统计网格路径数 a[i][j] = a[i][j - 1] + a[i - 1][j];
4. 对于一个栈，1-n的数字依次入栈，问出栈的种类数是多少
   假设第i个元素有h[i]种出管方式
   1 - k - 1    k.   n - k
   (1 - k - 1) -> 出栈
   k , (n - k) -> n - k
   假设第k个数是最后一个出栈的，那么比k早入栈且出栈的有k-1个数, 种类数有h[k - 1], 比k晚入栈且早出栈的有n - k个数，种类数有h[n - k]个，因此总共有h[k - 1] * h[n - k]种
   那么h[n] = sigma(k = 1, n) h[k - 1] * h[n - k]
   拓展：卡特兰数 C(n, 2n) / (n + 1) = (2n!) / n! * (n + 1)!
   n -> 入栈 1 出栈 -1
   -1 -1 1 1 1 1   不合法序列: 存在一个前缀和，使得它的值小于0
   n+1 1, n-1 -1   C(n + 1, 2n)   C(n, 2n)
## 进阶递推问题
矩阵快速幂
### 普通快速幂
可以logn复杂度求出一个数的幂的算法
2 ^ 10, 1010 -> 2 ^ (1000) * 2 ^ (10 * 1) 
### 矩阵快速幂
矩阵快速幂和快速幂非常相似，只不过是把原来的乘法重载成了矩阵乘法
矩阵快速幂有什么用呢？ 如果我们能求出一个问题的递推式，但是这个递推式非常复杂，常规的递推不能满足题目要求的复杂度，就可以把递推式转换成矩阵通过算矩阵的幂把原来O(n)的复杂度降到O(logn)
举个例子，对于斐波那契数列求和可以看这道题：https://ac.nowcoder.com/acm/contest/115567/H
1s内通过1e9是不可能的，因此要找到一个优化方法，我们可以考虑用矩阵来重写公式，从而把这个加法的递推式变成乘法递推式
观察这个斐波那契数列的式子f(n) = f(n - 1) + f(n - 2)
我们把fib(n)表示成一个1x2的矩阵[F(n), F(n - 1)] 那么fib(n - 1)就是[F(n - 1), F(n - 2)]
所以我们要找到的是一个[F(n), F(n - 1)] = [F(n - 1), F(n - 2)] * base的base矩阵
由题意可知base矩阵一定是一个2x2的矩阵，而又知道
F_n = 1 * F_(n - 1) + 1 * F_(n - 2);
F_(n - 1) = 1 * F_(n - 2) + 0 * F_(n - 2)
所以我们能得出这个base矩阵就是[[1, 1][1, 0]]
![](https://root0073-image.oss-cn-beijing.aliyuncs.com/img/1ada4272e90ce4143f201b6dc29b09d4.png)
那么接下来就很简单，我们已知[F_2, F_1] 是[1, 1]，直接一直累乘上来用快速幂计算即可优化到logn级别
即[F_n, F_(n - 1)] = [F_2, F_1] * base^(n - 2)


![](https://root0073-image.oss-cn-beijing.aliyuncs.com/img/36f3a48fa4386d25a755943bba8f85da.png)