# 1550. 存在连续三个奇数的数组

题目链接：https://leetcode.cn/problems/three-consecutive-odds/description/
## 题目描述
给你一个整数数组 `arr`，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 `true` ；否则，返回 `false` 。

## 解题思路

#### final solution
遍历数组，判断第**i、i+1、i+2**三个元素是否都是奇数，如果是则返回`true`，否则返回`false`。
时间复杂度为**O(n)**，空间复杂度为**O(1)**。

## 代码实现
```cpp
class Solution {
public:
    bool threeConsecutiveOdds(vector<int>& arr) {
        for(int i=0;i+2<arr.size();i++){
            if(arr[i]%2==1&&arr[i+1]%2==1&&arr[i+2]%2==1)
            {
                return true;
            }
        }
        return false;
    }
};
```
![image-20251122000638337](file://C:\Users\Emma\AppData\Roaming\Typora\typora-user-images\image-20251122000638337.png?lastModify=1763881118)

------



# 485. 最大连续 1 的个数

题目链接：https://leetcode.cn/problems/max-consecutive-ones/description/
## 题目描述
给定一个二进制数组 `nums` ， 计算其中最大连续 **1** 的个数。

## 解题思路
#### Hint 1
> 考虑连续段1的性质?
<details>
<summary>Hint 1-Sol</summary>
连续段1一定以1开头(废话),在末尾碰到0或者数组的末尾时结束。
</details>

#### Hint 2
> 考虑如何记录连续段1的长度?
<details>
<summary>Hint 2-Sol</summary>
用一个变量记录连续段1的长度，每当碰到0或者数组的末尾时，更新最大长度。
</details>

#### final solution
遍历数组，记录连续段1的长度，更新最大长度。
时间复杂度为**O(n)**，空间复杂度为**O(1)**。

## 代码实现
```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int maxLen=0;
        int curLen=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==1){  // 是1，则当前长度+1
                curLen++;
            }
            else{  // 不是1，则当前长度达到这一轮的最大值，赋给max（打擂台），然后当前长度重置为0
                maxLen=max(maxLen,curLen);
                curLen=0;
            }
        }
        maxLen=max(maxLen,curLen);
        return maxLen;
    }
};
```
![image-20251122022733038](file://C:\Users\Emma\AppData\Roaming\Typora\typora-user-images\image-20251122022733038.png?lastModify=1763881132)

------



# 540. 有序数组中的单一元素(难)

题目链接：https://leetcode.cn/problems/single-element-in-a-sorted-array/description/
## 题目描述
给你一个仅由整数组成的**有序**数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

`有序想二分！`


## 解题思路
我最开始想的是哈希表，但是时间空间复杂度都是n，不好

```cpp
unordered_map<int, int> freq; // 出现频率用哈希表记录
for (int x : nums) freq[x]++; // 键（key）：数组里的整数  值（value）：出现次数
for (auto [k, v] : freq)
    if (v == 1) return k;
```

### solution 1 : 枚举

#### Hint 1
> 思考xor(异或)的性质?
<details>
<summary>Hint 1-Sol</summary>
异或运算有这个性质: <br>
任何数和其自身做异或运算的结果为 0，即 a xor a=0。
</details>

#### final solution
遍历数组，将所有元素进行异或运算，最终的结果就是只出现一次的那个数。
时间复杂度为**O(n)**，空间复杂度为**O(1)**。

## 代码实现
```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int ans=0;
        for(auto &i:nums) ans^=i;
        return ans;
    }
};
```
<img src="C:\Users\Emma\AppData\Roaming\Typora\typora-user-images\image-20251123134611243.png" alt="image-20251123134611243" style="zoom: 67%;" />

> 以下解法学有余力的同学可以尝试一下


### solution 2 : 二分

#### Hint 1
> 考虑这种形态的数组在相邻处的下标奇偶性?
<details>
<summary>Hint 1-Sol</summary>
举个例子 [1,1,2,2,3,4,4,5,5] <br>
index:  &nbsp &nbsp &nbsp 0 1 2 3 4 5 6 7 8  <br>
在单独的3前 arr[0]==arr[1] arr[2]==arr[3] <br>
在单独的3后 arr[4]!=arr[5] arr[6]!=arr[7] <br>
即我们要看偶数下标的数和他后面一个数是否相等！<br>
于是就产生了单调性，可以用二分查找。
</details>
#### final solution
二分查找，我们只关心偶数下标，**如果`arr[mid]==arr[mid+1]`，说明单独的数在mid之后，否则在mid之前**。
时间复杂度为**O(logn)**，空间复杂度为**O(1)**。

> 这个时间复杂度挺有标志性的，二分法

## 代码实现
```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int l=0,r=nums.size()-1;
        while(l<r){
            int mid=(l+r)/2;
            if(mid%2==1) mid--; //保证mid为偶数!!
            if(nums[mid]==nums[mid+1]) l=mid+2;
            else r=mid;
        }
        return nums[l];
    }
};
```

![image-20251123144933078](file://C:\Users\Emma\AppData\Roaming\Typora\typora-user-images\image-20251123144933078.png?lastModify=1763881230)

