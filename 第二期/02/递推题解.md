### 力扣509 斐波那契数
思路：我们已知斐波那契数列的递推式F(n) = F(n - 1) + F(n - 2), 处理一下边界f(1)和f(2)即可
需要注意斐波那契数列增长的速度非常快，当数据较大时记得开long long
代码
```
class Solution {
public:
    int fib(int n) {
	if(n == 0) {
		return 0;
	}
	if(n == 1) {
		return 1;
	}
	int pre1 = 0, pre2 = 1;
	int now = pre1 + pre2;
	n -= 2;
	while(n--) {
		int num = pre1 + pre2;
		pre1 = pre2, pre2 = num;
		now = pre1 + pre2;;
	}
	return now;
    }
};
```

### 力扣119 杨辉三角
#### 暴力做法
思路：我们建一个二维数组，把a[1][1]置为1，然后依据a[i][j] = a[i - 1][j - 1] + a[i - 1][j]的递推式即可得出答案
代码
```
class Solution {
public:
    vector<int> getRow(int rowIndex) {
	int a[35][35];
	for(int i = 1; i <= 34; i++) {
		a[i][1] = a[i][i] = 1;
	}
	for(int i = 1; i <= 34; i++) {
		for(int j = 2; j <= i - 1; j++) {
			a[i][j] = a[i - 1][j - 1] + a[i - 1][j];
		}
	}
	int n = rowIndex + 1;
	vector<int> ans;
	for(int i = 1; i <= n; i++) {
		ans.push_back(a[n][i]);
	}
	return ans;
    }
};
```
#### 空间优化
由于我们直接开一个二维的数组会有一半空间用不到，我们可以直接利用滚动数组的方式来优化空间，创建两个数组一个pre一个now，pre存储上行数据，now用来计算这行的数据
在一行结束时把pre换成now再来计算下一轮，这样可以很好的降低空间开销
代码：
```
class Solution {
public:
    vector<int> getRow(int rowIndex) {
		vector<int> pre(35), now(35);
		int cnt = 2;
		pre[1] = 1;
        now = pre;
		int n = rowIndex;
        int nn = n;
		while(n--) {
			for(int i = 1; i <= cnt; i++) {
				now[i] = pre[i - 1] + pre[i];
			}
			cnt++;
			pre = now;
		}
		vector<int> ans;
		for(int i = 1; i <= nn + 1; i++) {
			ans.push_back(now[i]);
		}
		return ans;
    }
};
```