[toc]

# 3354 使得数组元素等于零

## 题目描述

给你一个整数数组 `nums` 。

开始时，选择一个满足 `nums[curr] == 0` 的起始位置 `curr` ，并选择一个移动 **方向** ：向左或者向右。

此后，你需要重复下面的过程：

- 如果 `curr` 超过范围 `[0, n - 1]` ，过程结束。
- 如果 `nums[curr] == 0` ，沿当前方向继续移动：如果向右移，则 **递增** `curr` ；如果向左移，则 **递减** `curr` 。
- 如果 `nums[curr] > 0`
  - 将 `nums[curr]` 减 1 。
  - **反转** 移动方向（向左变向右，反之亦然）。
  - 沿新方向移动一步。

如果在结束整个过程后，`nums` 中的所有元素都变为 0 ，则认为选出的初始位置和移动方向 **有效** 。

返回可能的有效选择方案数目。

**示例 1：**

**输入：**`nums = [1,0,2,0,3]`

**输出：`2`

**解释：**

可能的有效选择方案如下：

- 选择 

  ```
  curr = 3
  ```

   并向左移动。

  - `[1,0,2,**0**,3] -> [1,0,**2**,0,3] -> [1,0,1,**0**,3] -> [1,0,1,0,**3**] -> [1,0,1,**0**,2] -> [1,0,**1**,0,2] -> [1,0,0,**0**,2] -> [1,0,0,0,**2**] -> [1,0,0,**0**,1] -> [1,0,**0**,0,1] -> [1,**0**,0,0,1] -> [**1**,0,0,0,1] -> [0,**0**,0,0,1] -> [0,0,**0**,0,1] -> [0,0,0,**0**,1] -> [0,0,0,0,**1**] -> [0,0,0,0,0]`.

- 选择 

  ```
  curr = 3
  ```

   并向右移动。

  - `[1,0,2,**0**,3] -> [1,0,2,0,**3**] -> [1,0,2,**0**,2] -> [1,0,**2**,0,2] -> [1,0,1,**0**,2] -> [1,0,1,0,**2**] -> [1,0,1,**0**,1] -> [1,0,**1**,0,1] -> [1,0,0,**0**,1] -> [1,0,0,0,**1**] -> [1,0,0,**0**,0] -> [1,0,**0**,0,0] -> [1,**0**,0,0,0] -> [**1**,0,0,0,0] -> [0,0,0,0,0].`

**示例 2：**

**输入：**`nums = [2,3,4,0,4,1,0]`

**输出**：`0`

**解释：**

不存在有效的选择方案。

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`
- 至少存在一个元素 `i` 满足 `nums[i] == 0` 。

## 方案

+ 注意到当`num[i]==0`时 答案统计与`i`的前缀和、后缀和有关
+ 当前缀和与后缀和相等时，选择左或右都能满足条件
+ 当前缀和不等于后缀和时，当且仅当两个差值为1才被统计
+ 不等的情况下，选择和更大的一侧是最优

## 代码

```
class Solution {
public:
    int countValidSelections(vector<int>& nums) {
        int n=nums.size();
        int ans=0;
        vector<int> pre(n+1,0),suf(n+1,0);
        pre[0]=nums[0];
        for(int i=1;i<n;i++){
            pre[i]=pre[i-1]+nums[i];
        }
        for(int i=n-1;i>=0;i--){
            suf[i]=suf[i+1]+nums[i];
        }
        for(int i=0;i<n;i++){
            if(!nums[i]){
            if(pre[i]==suf[i])ans++;
            else if(abs(suf[i]-pre[i])<=1)ans++;
            }
        }
        return ans;
    }
};
```

# 525 连续数组

## 题目描述

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1：**

```
输入：nums = [0,1]
输出：2
说明：[0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2：**

```
输入：nums = [0,1,0]
输出：2
说明：[0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 3：**

```
输入：nums = [0,1,1,1,1,1,0,0,0]
输出：6
解释：[1,1,1,0,0,0] 是具有相同数量 0 和 1 的最长连续子数组。
```

## 方案

+ 寻找`cnt1==cnt0`的最长子数组，转换成式子就是`cnt1[r]-cnt1[l-1]=cnt0[r]-cnt0[l-1]`
+ 构建前缀和数组对应`cnt1=pre，cnt0=i-pre,s=cnt1-cnt0`
+ map存 s 对应的最小下标

## 代码

```
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n = nums.size();
        map<int, int> mp;
        vector<int> pre(n + 1, 0),s(n+1,0)
        for (int i = 1; i <= n; i++) {
            pre[i] = pre[i - 1] + nums[i-1];
            s[i]=pre[i]-(i-pre[i]);
        }
        mp[0] = 0;
        int ans = 0;
        //pre[i]==pre[i]-
        for (int i = 1; i <= n; i++) {
            int x = s[i];
            if (mp.count(x)) {//不能用mp[x]判断 因为返回的是mp[x]是否为0而不是mp是否存在x的键值对
                ans = max(ans, i - mp[x]);//同时会在mp插入x,污染mp
            } else
                mp[x] = i;
        }
        return ans;
    }
};
```

