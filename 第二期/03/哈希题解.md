## 1636. 按照频率将数组升序排序

题目要求将数组中的元素按频率升序排序，其次按元素大小降序排序。我们可以直接再创建一个数组维护我们所需的信息，然后使用sort排序。由于两次排序的逻辑相反，我们需要重写排序函数，这里我直接使用了lambda表达式传入函数变量。

以下是AC代码：

```cpp
class Solution {
public:
    vector<int> frequencySort(vector<int>& nums) {
       
        map<int,int> mp;
        vector<pair<int,int>> ans;
        for(auto i:nums)
        {
            mp[i]++;
        }    
        for(auto [x,y]:mp)
        {
            if(y>0)
            {
                ans.push_back({y,x});
            }
        }
        sort(ans.begin(), ans.end(), [&](pair<int, int> a, pair<int, int> b)
        {
            if (a.first == b.first)return a.second > b.second;
            return a.first < b.first;
        });
        vector<int> sum;
        for(auto [x,y]:ans)
        {
            for (int i=0;i<x;i++)
            {
                sum.push_back(y);
            }
        }
        return sum;
    }
};
```

## 532. 数组中的 k-diff 数对

我们直接使用哈希表来记录信息，因为哈希表天然有序，所以在遍历时只需考虑比当前值大k的数字是否存在。解释一下为什么使用map：因为unordered_map的底层实现是哈希表，由于O(1)的查询修改性能太强，某些数据可能故意制造哈希冲突，导致复杂度降为O(n)。解决方法是用map（底层红黑树，常数大但稳定）或重写哈希函数。使用unordered_map时要注意数据范围。

以下是AC代码：

```cpp
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
       map<int, int> mp;
        int ans = 0;
        for (auto i : nums)
        {
            mp[i]++;
        }
        if (k==0)
        {
            for (auto i : mp)
            {
                if (i.second >1)
                    ans++;
            }
            return ans;
        }
        for (auto &[x,y] : mp)
        {
            if (mp.find(x-k)!=mp.end())
            {
                ans++;
            }
        }
        return ans;
    }
};
```

## LCR 007. 三数之和

题目要求寻找三个数字，我们可以采用"定一找二"的策略：遍历排序后的nums数组，假设当前数字是三元组中最小的，将left设为i+1，right设为n-1，使用双指针寻找合法的两个数。注意处理重复元素的情况，确保结果不包含重复三元组。

以下是AC代码：

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums)
    {
        vector<vector<int>> ans;
        if (nums.size() < 3)
        {
            return ans;
        }
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; i++)
        {
            if (i>0 && nums[i] == nums[i - 1])
            {
                continue;
            }
            int tar = -nums[i];
            int left=i+1;  
            int right = nums.size() - 1;

            while (left < right)
            {
                int sum = nums[left] + nums[right];
                if (sum == tar)
                {
                    ans.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1])
                        left++;
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    left++;
                    right--;
                }
                else if
                (sum < tar)
                {
                    left++;  
                }
                else
                {
                    right--; 
                }
            }
        }
        return ans;
    }
};
```

