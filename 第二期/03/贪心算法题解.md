# 2078. 两栋颜色不同且距离最远的房子
[题目链接](https://leetcode.cn/problems/two-furthest-houses-with-different-colors/description/)
## 题目描述
街上有 $n$ 栋房子排成一列,每栋房子都粉刷上了漂亮的颜色。给你一个下标从 $0$ 开始且长度为 $n$ 的整数数组 `colors`,其中 `colors[i]` 表示第 `i` 栋房子的颜色。

返回两栋**颜色不同**房子之间的最大距离。
>第 `i` 栋房子和第 `j` 栋房子之间的距离是 `abs(i - j)`。
## 解题思路

#### Hint 1
> 考虑哪些地方的颜色提供了最大贡献？
<details>
<summary>Hint 1-Sol</summary>
首尾的房子一定作为最大贡献的端点
</details>

#### Hint 2
> 证明之
<details>
<summary>Hint 2-Sol</summary>
考虑反证
考虑存在一种方案的端点不是首尾，是l-r
1.一开始的放在和左端点颜色相同，那么左端点取开始肯定更优
2.一开始的放在和右端点颜色相同，那么右端点取结束肯定更优
3.如果左端点和l颜色不同且右端点和r颜色不同，那么必定存在一个方案使得端点取左端点或者右端点更优，读者可自行讨论得出
</details>

#### final solution
1. 首先判断首尾颜色是否相同，如果相同则首尾房子颜色相同，需要遍历数组找到首尾颜色不同的房子，计算距离。
2. 如果首尾颜色不同，则首尾房子颜色不同，直接计算距离即可。
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$
## 代码实现
```cpp
class Solution {
public:
    int maxDistance(vector<int>& colors) {
        int n=colors.size();
        int col1=colors[0],col2=colors[n-1];
        if(col1!=col2) return n-1;
        int ans=0;
        for(int i=n-1;i>=0;i--) {
            if(colors[i]!=col1){
                ans=max(ans,i-0);
            }
        }
        for(int i=0;i<=n-1;i++){
            if(colors[i]!=col2){
                ans=max(ans,n-1-i);
            }
        }
        return ans;
    }
};
```
---

# 1005. K 次取反后最大化的数组和
[题目链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)
## 题目描述
给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：
选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。
重复这个过程恰好 `k` 次，下标 `i` 可以相同。
返回 `k` 次修改数组后可能的最大的和。

## 解题思路

#### Hint 1
> 怎样去操作是最优秀的？
<details>
<summary>Hint 1-Sol</summary>
把最小负数变成正数是最优的
</details>

#### Hint 2
> k溢出了怎么办
<details>
<summary>Hint 2-Sol</summary>
如果k溢出了
1.如果k剩下了偶数，直接对一个数反复取反，对和没有影响
2.如果k剩下了奇数，那么必定存在一个数反复取反，对和有影响，那么必定是绝对值最小的那个数反复取反，对和的影响最小
</details>

#### final solution
1. 首先对数组进行排序，然后遍历数组，将负数变为正数，同时将k减1。
2. 判断k的奇偶性，如果k为奇数，则将最小的正数变为负数。
- 时间复杂度：$O(nlogn)$
- 空间复杂度：$O(1)$

## 代码实现
```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        for(auto &i:nums){
            if(i<0&&k){
                i=-i;
                k--;
            }
        }
        int sum=accumulate(nums.begin(),nums.end(),0);
        if(k&1){
            sum-=2*(*min_element(nums.begin(),nums.end()));
        }
        return sum;
    }
};
```
---

# 881. 救生艇
[题目链接](https://leetcode.cn/problems/boats-to-save-people/description/)
## 题目描述
给定数组 `people` 。`people[i]`表示第 `i`个人的体重 ，`limit` 表示每艘船可以承载的最大重量。
每艘船最多可同时载两人，但条件是这些人的重量之和最多为 `limit`。
返回载到每一个人所需的最小船数。(保证每个人都能被船载)

## 解题思路

#### Hint 1
> 我们考虑把数组排序，从小到大去处理，对一个小的数，我们和什么数配对的优的？
<details>
<summary>Hint 1-Sol</summary>
和小于等于lim-x的最后一个数配对
</details>

#### Hint 2
> 证明之？

假设某个最优解 $S$ 中，最轻者 $L$ 没有与 $H$ 同船，而是与较轻者 $P$ 同船（或 $L$ 独居，此时 $P$ 视为 $0$），且 $H$ 在另一艘船上（与 $Q$ 同船或独居）。

我们进行如下**交换**：让 $L$ 与 $H$ 同船，让 $P$ 与 $Q$ 同船。

1.  **新船 $(L, H)$**：根据定义，$H$ 是 $L$ 能匹配的最重的人，故 $weight(L) + weight(H) \le limit$，**合法**。
2.  **新船 $(P, Q)$**：因为 $weight(P) \le weight(H)$，且原解中 $(H, Q)$ 合法，则 $weight(P) + weight(Q) \le weight(H) + weight(Q) \le limit$，故**也合法**。

**结论**：
交换后所有人的配对依然合法，且使用的船只数量**没有增加**。这说明我们可以把任何一种最优解无损地调整为贪心解，证毕。


#### final solution
用multiset维护一个有序的数组，每次取最小的数，然后找到小于等于lim-x的最后一个数，如果存在，则配对，否则自己一个船。
时间复杂度：$O(nlogn)$
空间复杂度：$O(n)$

## 代码实现
```cpp
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        multiset<int> s;
        for(auto i:people) s.insert(i);
        int ans=0;
        while(!s.empty()){
            auto it=*s.begin();
            auto it2=s.upper_bound(limit-it);
            if(it2!=s.begin()){
                it2--;
            }
            if(it2!=s.begin()){
                s.erase(it2);
            }
            s.erase(s.begin());
            ans++;
        }
        return ans;
    }
};
```
---