# 贪心

## 概念
贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。  
也就是说，不从整体最优上加以考虑，它所做出的仅是在某种意义上的**局部最优解**。

简单来说，贪心算法的核心思想是：
> “走一步看一步，只顾眼前的利益。”

虽然贪心算法不能对所有问题都得到整体最优解，但对于很多问题（如最小生成树、活动安排、部分背包问题等），它能产生整体最优解。

**注意**：使用贪心算法的关键在于**证明**贪心策略的正确性（通常使用**反证法**或**交换论证法**）。如果无法证明局部最优能推导出全局最优，则不能贸然使用。

>由于这是个很灵活的算法，所以没有啥固定的模板，具体问题具体分析。

## 例题
### 561. 数组拆分
[题目链接](https://leetcode.cn/problems/array-partition/description/?envType=problem-list-v2&envId=greedy)

#### 题目描述
给定一个长度为 `2n` 的整数数组 `nums` ，你的任务是将这些数分成 `n` 对，使得从 `1` 到 `n` 的 `min(ai, bi)` 总和最大。

#### final solution
把数组排序后，两个数两个数作为一对。

#### 代码实现
```cpp
class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int sum=0;
        for(int i=0;i<nums.size();i+=2){
            sum+=nums[i];
        }
        return sum;
    }
};
```

#### 证明

我们使用交换论证法来证明：假设数组已经从小到大排序为 $a_1 \le a_2 \le \dots \le a_{2n}$。考虑最小的元素 $a_1$。在任何分组方案中，$a_1$ 必定是某一组 $(a_1, x)$ 的最小值（因为它是全局最小值）。因此，$a_1$ 一定会贡献到总和中。为了让总和最大，我们希望“牺牲”掉的那个 $x$ 尽可能小，从而保留更大的数去贡献给其他的组。如果我们把 $a_1$ 和 $a_2$ 配对，贡献为 $a_1$，牺牲了 $a_2$。如果我们把 $a_1$ 和 $a_k (k > 2)$ 配对，贡献为 $a_1$，牺牲了 $a_k$。显然，牺牲 $a_2$ 比牺牲 $a_k$ 更划算，因为 $a_2$ 较小，保留下来的 $a_k$ 有机会在后面作为更大的最小值贡献分数。同理，处理完 $(a_1, a_2)$ 后，剩余元素中最小的是 $a_3$，应用同样的逻辑，它应该与 $a_4$ 配对。故：排序后相邻两两配对最优。

## 作业
#### 2078. 两栋颜色不同且距离最远的房子
[题目链接](https://leetcode.cn/problems/two-furthest-houses-with-different-colors/description/)

#### 1005. K 次取反后最大化的数组和
[题目链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)

#### 881. 救生艇
[题目链接](https://leetcode.cn/problems/boats-to-save-people/description/)