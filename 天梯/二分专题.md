# P1102 A-B 数对

https://www.luogu.com.cn/problem/P1102

### 解析

这题一上来肯定是两个 for 循环，暴力解法。

```cpp
#include<iostream>
#include<cmath>

using namespace std;

const int N = 200010;

int n, C;
int q[N];

int main() {
    cin>>n>>C;
    for(int i = 0; i < n; i++) {
        cin>>q[i];
    }
    int cnt = 0;
    for(int a = 0; a < n; a++) {
        for(int b = a; b < n; b++) {
            if(abs(q[a] - q[b]) == C) cnt++;
        }
    }
    cout<<cnt;
    return 0;
}
```

结果76，有三个超时了。正常，两个 for 不超时才怪。要想更快的方法。

------

我们可以使用**二分**，先用 sort 排好序就行，时间复杂度为**O(log₂n)**。
二分是用来查找一个数的，这里要查找什么呢？

**我们可以固定 B，则 A = B + C，只用查找 A 就行。**

内部循环：查找 A，用二分；
外部循环：遍历 B，用 for。

------

**如何找第一个满足条件的A？（固定模板）**

```
我们举例说明，C = 1，数列：
1 2 2 3 
现在 B = 1，要找第一个满足条件的A，A = 1 + 1 = 2
1 2 2 3
l m   r  mid = (0 + 3)>>1 = 1，q[1] = 2        所以 mid = x，则令 r = mid		  ->当找到一个x时，会进一步缩小范围，
l r		 mid = (0 + 1)>>1 = 0，q[0] = 1 < 2 	  所以 mid < x，则令 l = mid + 1 	看它前面的值是不是x，实现找第一个
  l
  r      l = r，循环停止

比如我们再看另一种情况：
1 2 2 3 4
其他条件都不变，数列加了一个数。
1 2 2 3 4
l       r  	mid = (0 + 4)>>1 = 2，q[2] = 2      所以 mid = x，则令 r = mid（同上，缩小范围看它前面还有没有x）
l   m	   	mid = (0 + 2)>>1 = 1，q[1] = 2	   所以 mid = x，则令 r = mid
l m		   	后面和第一个例子一模一样，不赘述了。
可以看到，这个例子里，第一次二分查找到的mid就不是第一个x，通过缩小范围才找到了第一个。
```

我们可以尝试实现这部分代码： 

```cpp
int bSearch(int q[], int len, int x) {
    int l = 0, r = len - 1. mid;
    while(l < r) {
        mid = (l + r) >> 1;
        if(x > q[mid]) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    if(q[l] == x) return l;
    else return -1;
}
```

------

于是本题代码如下：（只写了一部分，写不下去了）

```cpp
#include<iostream>
#include<algorithm>  // 需要 sort

using namespace std;

typedef long long LL;
const int N = 200010;

long long n, C;
long long q[N];

// 找第一个满足条件的A
int bSearch1(LL q[], int len, LL x) {
    int l = 0, r = len - 1, mid;
    while(l < r) {
        mid = (l + r) >> 1;
        if(x > q[mid]) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    if(q[l] == x) return l;
    else return -1;
}

// 
int bSearch2(LL q[], int len, LL x) {
    int l = 0, r = len - 1, mid;
    while(l <= r) {
        mid = (l + r) >> 1;
        if(x > q[mid]) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    if(q[l] == x) return l;
    else return -1;
}

int main() {
    cin>>n>>C;
    for(int i = 0; i < n; i++) {
        cin>>q[i];
    }
    sort();
    long long cnt = 0;
    for(int B = 0; B < n; B++) {
        int A = B + C;
        int res1 = bSearch1(q, n, A);
        if(res1 == -1) {
            continue;
        } else {
            int res2 = bSearch2(q, n, A);
            cnt += res2 - res1 + 1;
        }

    }
    cout<<cnt;
    return 0;
}
```

未解决。